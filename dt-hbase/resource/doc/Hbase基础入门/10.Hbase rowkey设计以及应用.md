1.Hbase中的热点问题：
  Hbase中的行是按照rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近
位置，便于scan。然而糟糕额rowkey设计是热点的源头。热点发生在大量的client直接访问集群的一个或极少数个节点(访问可
能是读，写或者其他操作)。设计良好的数据访问模式以使集群被充分，均衡的利用。

  为了避免写热点，设计rowkey使得不同航仔用一个region，但是在更多数据情况下，数据应该被写入集群的多个region，而不是一个。
  
2.rowkey设计的原则
  2.1 唯一性原则
      必须在设计上保证其唯一性，rowkey是  按照字典顺序排序存储的。因此设计rowkey的时候，要充分利用这个排序的特点，将经常
  读取的数据存储到一块，将最近可能会访问的数据放到一块。
  
  2.2 长度原则
      rowkey是一个二进制流，可以是任意字符串，最大长度64kb，实际应用中一般为10~100bytes，以byte[]形式保存，一般设计成定长。
  建议越短越好，不要超过16个字节，原因是因为目前操作系统都是64位的，内存8字节对齐，控制在16个字节，8字节的
  整数倍利用了操作系统的最佳特性。

  2.3 散列原则
      如果rowkey按照时间戳的方式递增，不要将时间放在二进制码的前面，建议将rowkey的高位采用散列字段处理，由程序随机生成，低位
  放时间字段，这样将提高数据均衡分布在每个RegionServer，以实现负载均衡的几率。
      如果不进行散列字段处理，首字段直接使用时间信息，所有的数据都会集中在一个RegionServer上，这样在数据检索的时候负载会集中在
  个别的RegionServer上，造成热点问题，会降低查询效率。	  
  
  2.4 盐析(salt)
      这里所说的加盐不是密码学中的加盐，而是在rowkey的前面增加随机数，具体就是给rowkey分配一个随机数前缀以使得它和之前的rowkey的
  开头不同。分配的前缀种类数量应该和你想使用数据分散到不同的region的数量一致。加盐之后的rowkey就会根据随机生成的前缀分散到各个region
  上，以避免热点。
  
  2.5 哈希
      哈希会使用同一行永远用一个前缀加盐。哈希也可以使负载分散到整个集群，但是读取是可以预测的。使用确定的哈希可以让客户端重构完整
  的rowkey，可以使用get操作准确获取某一个行数据
  
  2.6 反转
      第三种防止热点的方法是反转固定长度或者数字格式的rowkey。这样可以使得rowkey中经常改变的部分(最没有意义的部分)放在前面。这样可以有效
  的随机rowkey，但是牺牲了rowkey的有序性。
      反转rowkey的例子以手机号为rowkey，可以将手机号反转后的字符串作为rowkey，这样就可以避免了以手机号那样比较固定开头导致热点问题。
 
3.案例分析
  以电信公司通话记录为例，一般会存储下面一些字段:
  (1)主叫(callerId)
  (2)被叫(calleeId)
  (3)通话时长
  (4)通话时间(callTime)
  (5)主叫位置
  (6)被叫位置
  考虑在不同的场景下，如何设计rowkey？
  可能会有如下的需求：
  (1)查询最近的个人详单
  (2)办案人员查询最近谁跟某人有过联系
  
  对于需求(1)想要查询个人通话详单，可能rowkey设计为如下：
      {主叫},{被叫},{通话时间}
  这样会不会有问题呢？由于rowkey是按照字典顺序排序的。当个人查询自己的详单时，由于主叫作为了roweky的前缀，而查询人员查询自己的详单的同时，主叫就是自己并且固定
就会造成热点问题。所以我们需要有关于个人的数据分散到不用的服务器上。假设有10个Region编号为00~09,我们可以进行盐析处理。
  一般情况下根据业务，我们查询个人详单都会查询时间范围内的通话记录，所以rowkey可能设计如下:
      {主叫},{通话时间},{被叫}
  可以针对{主叫},{通话时间}联合的hash做盐析处理，如果只查询月度账单就要用{主叫},{通话时间yyyymm}到月份的联合起来hash做盐析处理。所以rowkey可能被设计成下面这样:
      {主叫+通话时间yyyymm}.hashCode()%10,{主叫},{通话时间},{被叫}
  假设现在需要查询18629191109这个人的2月打出电话的记录，可以这样设置：
      startKey=xx,18629191109,20170201
	  endKey  =xx,18629191109,20170301
	  
  那么问题又来了，如果需要查询这个人2月的详单应该如何设计呢？需要注意的是详单包括我打给某人(我是主叫)以及某人打给我的(我是被叫)。
  好的解决方案就是使用二次索引,所以需要再设计一张表存储被叫记录(calleelogs),它的rowkey设计为:{通话时间},{被叫}。value存储主叫表的rowkey。此时就需要通过协处理器，
当写入一条记录的时候，同时向被叫表也写入一条数据。
  所以整体的设计大概是下面这个样子：
  主叫表(callerlogs)
  rowkey=xx,callerId,callTime,calleeId  value=...
  被叫表(calleelogs)
  rowkey=calleeId,callTime,callerId     value=callerlogs.rowkey
  
4.案例开发
  4.1 建表
     create 'ns1:calllogs', 'f1'
	 
  4.3 编写代码,打包上传至服务器，分发jar到hbase集群的hbase/lib目录下
      代码路径:com.it18zhang.app.calllog.*
	  
  4.2 在hbase/conf/hbase-site.xml添加下面的配置:
	  <property>
		  <name>hbase.coprocessor.region.classes</name>
		  <value>com.it18zhang.app.calllog.CalleeLogRegionObserver</value>
	  </property>